;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; tileCollision.asm
;
; Subroutine to test whether a tile position is ON in the
; playfield bitmap data generated by the Atari Tile Editor.
;
; USAGE
; -----
;   1. Set TileCheckCol (0-39) and TileCheckRow (0-47) in zero page.
;   2. JSR IsTileSet
;   3. On return: Carry SET = tile is ON, Carry CLEAR = tile is OFF
;
; To convert from raw screen coordinates:
;   TileCheckCol = screenPixelX / 4     (two LSR instructions)
;   TileCheckRow = scanLine    / 4     (two LSR instructions)
;
; CLOBBERS: A, X, Y
;
; HOW IT WORKS
; ------------
; The tile engine stores six playfield bitmaps (Bitmap0-5), each
; 193 bytes long, indexed by a Y register value that runs from 192
; (top of screen) down to 145 (bottom).
;
;   Y index = 192 - tileRow
;
; The 40 tile columns map to PF registers as follows:
;
;   Cols  0- 3  ->  Bitmap0 (left  PF0)  LSB-first in upper nibble
;   Cols  4-11  ->  Bitmap1 (left  PF1)  MSB-first
;   Cols 12-19  ->  Bitmap2 (left  PF2)  LSB-first
;   Cols 20-23  ->  Bitmap3 (right PF0)  LSB-first in upper nibble
;   Cols 24-31  ->  Bitmap4 (right PF1)  MSB-first
;   Cols 32-39  ->  Bitmap5 (right PF2)  LSB-first
;
; Two 40-byte lookup tables (ColBitmapLo / ColBitmapHi) hold the
; address of the correct bitmap for every column, and a third table
; (ColBitMask) holds the bitmask to AND against the loaded byte.
; The indirect-indexed instruction LDA (IsTilePtr),Y then fetches
; the exact byte from the correct bitmap in one instruction.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Zero-page variables  (add to your seg.u Variables block)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; seg.u Variables
    ; org $80

    ; TileCheckCol    ds 1    ; tile column to test  (0-39)
    ; TileCheckRow    ds 1    ; tile row    to test  (0-47)
    ; IsTilePtr       ds 2    ; scratch 16-bit pointer (2 bytes)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; IsTileSet subroutine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IsTileSet SUBROUTINE

    ; Point IsTilePtr at the correct bitmap for this column
    ldx TileCheckCol
    lda ColBitmapLo,x
    sta IsTilePtr
    lda ColBitmapHi,x
    sta IsTilePtr+1

    ; Compute bitmap row index: Y = 192 - TileCheckRow
    ; (row 0 = top of screen = index 192,
    ;  row 47 = bottom        = index 145)
    lda #192
    sec
    sbc TileCheckRow
    tay

    ; Load the bitmap byte for this row
    lda (IsTilePtr),y

    ; Mask off the single bit for this column
    ldx TileCheckCol
    and ColBitMask,x

    ; Return carry set if the tile is ON
    beq .off
    sec
    rts
.off
    clc
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Lookup tables  â€” reference your own bitmap labels below.
; Replace "wowMuchHello" with your tile map name.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Low byte of the bitmap address for each of the 40 columns
ColBitmapLo
    dc.b <wowMuchHelloBitmap0,<wowMuchHelloBitmap0      ; cols  0- 1
    dc.b <wowMuchHelloBitmap0,<wowMuchHelloBitmap0      ; cols  2- 3
    dc.b <wowMuchHelloBitmap1,<wowMuchHelloBitmap1      ; cols  4- 5
    dc.b <wowMuchHelloBitmap1,<wowMuchHelloBitmap1      ; cols  6- 7
    dc.b <wowMuchHelloBitmap1,<wowMuchHelloBitmap1      ; cols  8- 9
    dc.b <wowMuchHelloBitmap1,<wowMuchHelloBitmap1      ; cols 10-11
    dc.b <wowMuchHelloBitmap2,<wowMuchHelloBitmap2      ; cols 12-13
    dc.b <wowMuchHelloBitmap2,<wowMuchHelloBitmap2      ; cols 14-15
    dc.b <wowMuchHelloBitmap2,<wowMuchHelloBitmap2      ; cols 16-17
    dc.b <wowMuchHelloBitmap2,<wowMuchHelloBitmap2      ; cols 18-19
    dc.b <wowMuchHelloBitmap3,<wowMuchHelloBitmap3      ; cols 20-21
    dc.b <wowMuchHelloBitmap3,<wowMuchHelloBitmap3      ; cols 22-23
    dc.b <wowMuchHelloBitmap4,<wowMuchHelloBitmap4      ; cols 24-25
    dc.b <wowMuchHelloBitmap4,<wowMuchHelloBitmap4      ; cols 26-27
    dc.b <wowMuchHelloBitmap4,<wowMuchHelloBitmap4      ; cols 28-29
    dc.b <wowMuchHelloBitmap4,<wowMuchHelloBitmap4      ; cols 30-31
    dc.b <wowMuchHelloBitmap5,<wowMuchHelloBitmap5      ; cols 32-33
    dc.b <wowMuchHelloBitmap5,<wowMuchHelloBitmap5      ; cols 34-35
    dc.b <wowMuchHelloBitmap5,<wowMuchHelloBitmap5      ; cols 36-37
    dc.b <wowMuchHelloBitmap5,<wowMuchHelloBitmap5      ; cols 38-39

; High byte of the bitmap address for each of the 40 columns
ColBitmapHi
    dc.b >wowMuchHelloBitmap0,>wowMuchHelloBitmap0      ; cols  0- 1
    dc.b >wowMuchHelloBitmap0,>wowMuchHelloBitmap0      ; cols  2- 3
    dc.b >wowMuchHelloBitmap1,>wowMuchHelloBitmap1      ; cols  4- 5
    dc.b >wowMuchHelloBitmap1,>wowMuchHelloBitmap1      ; cols  6- 7
    dc.b >wowMuchHelloBitmap1,>wowMuchHelloBitmap1      ; cols  8- 9
    dc.b >wowMuchHelloBitmap1,>wowMuchHelloBitmap1      ; cols 10-11
    dc.b >wowMuchHelloBitmap2,>wowMuchHelloBitmap2      ; cols 12-13
    dc.b >wowMuchHelloBitmap2,>wowMuchHelloBitmap2      ; cols 14-15
    dc.b >wowMuchHelloBitmap2,>wowMuchHelloBitmap2      ; cols 16-17
    dc.b >wowMuchHelloBitmap2,>wowMuchHelloBitmap2      ; cols 18-19
    dc.b >wowMuchHelloBitmap3,>wowMuchHelloBitmap3      ; cols 20-21
    dc.b >wowMuchHelloBitmap3,>wowMuchHelloBitmap3      ; cols 22-23
    dc.b >wowMuchHelloBitmap4,>wowMuchHelloBitmap4      ; cols 24-25
    dc.b >wowMuchHelloBitmap4,>wowMuchHelloBitmap4      ; cols 26-27
    dc.b >wowMuchHelloBitmap4,>wowMuchHelloBitmap4      ; cols 28-29
    dc.b >wowMuchHelloBitmap4,>wowMuchHelloBitmap4      ; cols 30-31
    dc.b >wowMuchHelloBitmap5,>wowMuchHelloBitmap5      ; cols 32-33
    dc.b >wowMuchHelloBitmap5,>wowMuchHelloBitmap5      ; cols 34-35
    dc.b >wowMuchHelloBitmap5,>wowMuchHelloBitmap5      ; cols 36-37
    dc.b >wowMuchHelloBitmap5,>wowMuchHelloBitmap5      ; cols 38-39

; Bitmask to test for each of the 40 columns
ColBitMask
    ; PF0 left  (cols  0- 3): upper nibble, LSB-first (bit4=col0)
    dc.b $10,$20,$40,$80
    ; PF1 left  (cols  4-11): all bits, MSB-first (bit7=col4)
    dc.b $80,$40,$20,$10,$08,$04,$02,$01
    ; PF2 left  (cols 12-19): all bits, LSB-first (bit0=col12)
    dc.b $01,$02,$04,$08,$10,$20,$40,$80
    ; PF0 right (cols 20-23): same encoding as PF0 left
    dc.b $10,$20,$40,$80
    ; PF1 right (cols 24-31): same encoding as PF1 left
    dc.b $80,$40,$20,$10,$08,$04,$02,$01
    ; PF2 right (cols 32-39): same encoding as PF2 left
    dc.b $01,$02,$04,$08,$10,$20,$40,$80
