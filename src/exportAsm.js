const ROWS = 48
const TOTAL_BYTES = 193 // indices 0–192; assembly accesses 145–192

// PF0: upper nibble only, LSB first → bit4=col0, bit5=col1, bit6=col2, bit7=col3
function encodePF0(cells, colOffset) {
  return ((cells[colOffset + 0] ? 0x10 : 0) |
          (cells[colOffset + 1] ? 0x20 : 0) |
          (cells[colOffset + 2] ? 0x40 : 0) |
          (cells[colOffset + 3] ? 0x80 : 0))
}

// PF1: all 8 bits, MSB first → bit7=col0 … bit0=col7
function encodePF1(cells, colOffset) {
  return ((cells[colOffset + 0] ? 0x80 : 0) |
          (cells[colOffset + 1] ? 0x40 : 0) |
          (cells[colOffset + 2] ? 0x20 : 0) |
          (cells[colOffset + 3] ? 0x10 : 0) |
          (cells[colOffset + 4] ? 0x08 : 0) |
          (cells[colOffset + 5] ? 0x04 : 0) |
          (cells[colOffset + 6] ? 0x02 : 0) |
          (cells[colOffset + 7] ? 0x01 : 0))
}

// PF2: all 8 bits, LSB first → bit0=col0 … bit7=col7
function encodePF2(cells, colOffset) {
  return ((cells[colOffset + 0] ? 0x01 : 0) |
          (cells[colOffset + 1] ? 0x02 : 0) |
          (cells[colOffset + 2] ? 0x04 : 0) |
          (cells[colOffset + 3] ? 0x08 : 0) |
          (cells[colOffset + 4] ? 0x10 : 0) |
          (cells[colOffset + 5] ? 0x20 : 0) |
          (cells[colOffset + 6] ? 0x40 : 0) |
          (cells[colOffset + 7] ? 0x80 : 0))
}

function formatHexLine(bytes) {
  return '\thex ' + Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('')
}

export function exportAsm(name, grid) {
  // Build 6 bitmaps as Uint8Arrays, all zeroed (padding for unused indices)
  const bitmaps = Array.from({ length: 6 }, () => new Uint8Array(TOTAL_BYTES))

  for (let row = 0; row < ROWS; row++) {
    const yIndex = 192 - row          // row 0 → index 192, row 47 → index 145
    const cells = grid[row]           // 40 booleans

    bitmaps[0][yIndex] = encodePF0(cells, 0)   // left  PF0: cols 0–3
    bitmaps[1][yIndex] = encodePF1(cells, 4)   // left  PF1: cols 4–11
    bitmaps[2][yIndex] = encodePF2(cells, 12)  // left  PF2: cols 12–19
    bitmaps[3][yIndex] = encodePF0(cells, 20)  // right PF0: cols 20–23
    bitmaps[4][yIndex] = encodePF1(cells, 24)  // right PF1: cols 24–31
    bitmaps[5][yIndex] = encodePF2(cells, 32)  // right PF2: cols 32–39
  }

  // Sanitize name for use as an ASM label prefix
  const prefix = name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&') || 'Tile'

  const lines = [`; Tile map: ${name}`, `; Generated by Atari Tile Editor`, '']

  for (let b = 0; b < 6; b++) {
    lines.push(`${prefix}Bitmap${b}`)

    // First byte on its own line (matching original format)
    lines.push(formatHexLine(bitmaps[b].slice(0, 1)))

    // Remaining 192 bytes in lines of 16
    for (let i = 1; i < TOTAL_BYTES; i += 16) {
      lines.push(formatHexLine(bitmaps[b].slice(i, i + 16)))
    }

    lines.push('')
  }

  return lines.join('\n')
}
